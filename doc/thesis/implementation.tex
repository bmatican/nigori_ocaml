\chapter{Design and Implementation}
Different pieces of the system and how they are supposed to interact.
Each section should present the important work done inside it.
Before subpieces are introduced, the story of how the pieces will be put together will be presented.

Potentially list dependencies of modules to be able to link to them in the following.

\section{Shared}
Important, albeit smaller abstraction pieces such as nonces, revisions and configurations.
Details about bigger picture, major subcomponents and how they come together and will be used by either client or server.

Discuss how these pieces are the critical core part of the project, as they provide the abstraction capabilities, across platforms.

\subsection{Crypto}
\begin{itemize}
  \item primitives required for encryption and OCaml bindings
  \item derivation module for Nigori specifics
\end{itemize}

\subsection{Communication}
\begin{itemize}
  \item messages (described, as per RFC or code?)
  \item serialization (JSON, protobuf, details on choices)
  \item encoding (Base64, discussion on problems and choices)
  \item encryption and decryption (core of Nigori data handling -- probably talk in Client part)
\end{itemize}

\section{Server}
Details about what happens in the server.
Description of internals, state and data storage.

\subsection{Request Handling}
How actions are peformed through the RESTful interface.
How requests at endpoints get converted into actions on the server.
Filtering of requests, approval, authentication, responses.

List of requests and actions?

\subsection{Storage}
Abstractions for in-memory and SQLite storage.
Implementation details for both.
OCaml usefulness for implementation.
Provided interface from DB.

Quirks, problems and limitations.

\section{Client}
Details about how the client operates and discusses with the server.
Client key derivations, data encryption and such.
Message packaging, signing and marshalling.

\section{Testing}
Importance of having testing done in parallel to guarantee system integrity.
Details of the pieces of the system that have been tested and how?

\section{JavaScript implementation}
Discuss how the semi--automated version of the client to JS is done.
Explain manual pieces and how they had to be glued together.
Potentially show how, in the end, after boilerplate is overcome, changes to core get propagated to client, leading to fast prototyping.
