\chapter{Design and Implementation}
Nigori, as a system, is basically an encrypted key--value store, built for the cloud.
As such, the big picture consists of primarily two components: a client and a server.
Nevertheless, due to the nature of the interactions between these two pieces, quite a sizeable chunk of code ends up being shared, particularly the communication and encryption mechanics.
This chapter is modeled after the actual implementation, showing the shared code, and the client and the server in separation, while also discussing the interactions between them.

In adition to describing the base OCaml implementation, this chapter also provides details about the testing done to ensure the application performs according to specifications.
Lastly, the separate compilation from OCaml code to JavaScript is also detailed, along with both what it requires as well as what it entails.

TODO: potentially add a figure or set of figures showing module dependencies and individual pieces, to help with direct naming.

\section{Shared}
The coresponding section of the codebase for shared code actually represents the core of the application.
For the most part, components in this category are used by both the server and the client.
As such, they have been implemented according to the simplicity and modularity principles previously mentioned.
Implicitly, this made using this core in both client and server, a straightforward venture.
Moreover, it also allowed for an easy prototyping of the javascript version of the client, as well, since the core functionality was merely functorized to match the targetted platform.

\subsection{Crypto}
As listed in the initial draft for Nigori, several cryptographic functions are required for the operation of the protocol.
These functions were built on top of the cryptokit library for OCaml and abstracted into their individulal modules, each capable of providing the expected functionality as well as being tested or verified accordingly.

As such, we had several base primitives that were required:
\begin{description}
  \item[SHA-1] TODO: minor description
  \item[HMAC] TODO: explain customizations
  \item[PBKDF] TODO: detail process and link to RFC
  \item[DSA] TODO: explain what it is primarily used for
\end{description}

Of the primitives, the most important one was PBKDF.
This lies at the core of the encryption mechanics in Nigori.
Coupled with the central user password, this function is responsible for generating the keys that are then used both for authentication as well as encrypting the user's data.

TODO: explain how PBKDF is used for deriving keys.

TODO: give some minor overview of the constants used for PBKDF.

TODO: discuss how the keys are used for secret encryption

TODO: DSA usage patterns, forward reference messages; problems and solutions

\subsection{Communication}
\begin{itemize}
  \item specific data structures (nonces, revisions)
  \item messages (described, as per RFC or code?)
  \item serialization (JSON, protobuf, details on choices)
  \item encoding (Base64, discussion on problems and choices)
  \item encryption and decryption (core of Nigori data handling -- probably talk in Client part)
\end{itemize}

\subsection{Extra}
Details about nonces, constants and default configurations; utility function from the library core

\section{Server}
Details about what happens in the server.
Description of internals, state and data storage.

\subsection{Request Handling}
How actions are peformed through the RESTful interface.
How requests at endpoints get converted into actions on the server.
Filtering of requests, approval, authentication, responses.

List of requests and actions?

\subsection{Storage}
As far as storage was concearned, the server had several requirements.
On the one hand, the server needs to hold both explicit user data, as well as certain pieces of metadata, for security purposes.
For example, nonce and timestamp data is recorded in the system, on a per user basis, to prevent potential replay attacks.
This goes in line with the requirements of the specification.

On the other hand, design wise, we had the choice of either a memory based storage system or an actual physical storage one.
In the end, we decided to opt for both, as the module system in OCaml made functorizing the aforementioned required functionality relatively easy to achieve.


Abstractions for in-memory and SQLite storage.
Implementation details for both.
OCaml usefulness for implementation.
Provided interface from DB.

Quirks, problems and limitations.

\section{Client}
Details about how the client operates and discusses with the server.
Client key derivations, data encryption and such.
Message packaging, signing and marshalling.

\section{Testing}
Importance of having testing done in parallel to guarantee system integrity.
Details of the pieces of the system that have been tested and how?

\section{JavaScript implementation}
Discuss how the semi--automated version of the client to JS is done.
Explain manual pieces and how they had to be glued together.
Potentially show how, in the end, after boilerplate is overcome, changes to core get propagated to client, leading to fast prototyping.
